# Phase 1: Base FastAPI Setup

> **Status**: Ready to implement
> **Estimated Time**: 2-4 hours
> **Dependencies**: None (greenfield)
> **Python Version**: 3.14 (modern, with latest Pydantic support)

---

## Overview

This phase establishes the foundational FastAPI application with:
- **Python 3.14** (latest stable with enhanced async performance)
- Modern package management (`uv`)
- Structured logging (`loguru`)
- Type-safe configuration (`pydantic-settings` v2+)
- Feature-based directory structure
- Docker containerization (multi-stage Alpine build)
- Development hot-reload
- Health check endpoints
- CORS configuration

---

## Table of Contents

1. [Directory Structure](#directory-structure)
2. [Setup Steps](#setup-steps)
3. [File-by-File Implementation](#file-by-file-implementation)
4. [Docker Setup](#docker-setup)
5. [Testing](#testing)
6. [Success Criteria](#success-criteria)
7. [Troubleshooting](#troubleshooting)

---

## Directory Structure

Create the following structure:

```
junjo-server/
├── backend/                          # Old Go backend (keep for now)
│   └── ...
│
├── backend_python/                   # NEW - Python backend
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                   # FastAPI app entry point
│   │   │
│   │   ├── config/
│   │   │   ├── __init__.py
│   │   │   ├── settings.py           # Pydantic Settings
│   │   │   └── logger.py             # Loguru setup
│   │   │
│   │   ├── features/                 # Feature folders (empty for now)
│   │   │   └── __init__.py
│   │   │
│   │   └── common/                   # Shared utilities
│   │       ├── __init__.py
│   │       └── responses.py          # Standard response models
│   │
│   ├── .env.example
│   ├── .env                          # Create from example
│   ├── .python-version               # Python 3.14
│   ├── pyproject.toml                # uv/pip dependencies
│   ├── uv.lock                       # Generated by uv
│   ├── Dockerfile
│   ├── .dockerignore
│   └── README.md
│
├── docker-compose.dev.yml            # Update to include Python backend
└── PYTHON_BACKEND_MIGRATION_*.md     # Migration docs
```

---

## Setup Steps

### Step 1: Create Directory Structure

```bash
# From junjo-server root
mkdir -p backend_python/app/{config,features,common}

# Create __init__.py files
touch backend_python/app/__init__.py
touch backend_python/app/config/__init__.py
touch backend_python/app/features/__init__.py
touch backend_python/app/common/__init__.py
```

### Step 2: Set Python Version

```bash
cd backend_python

# Specify Python 3.14
echo "3.14" > .python-version
```

### Step 3: Initialize uv Project

```bash
# Install uv if not already installed
# curl -LsSf https://astral.sh/uv/install.sh | sh

# Initialize uv project
uv init --no-readme --no-workspace

# This creates pyproject.toml
```

### Step 4: Add Dependencies

Edit `backend_python/pyproject.toml`:

```toml
[build-system]
requires = ["setuptools>=75.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "junjo-backend"
version = "0.1.0"
description = "Junjo Server Python Backend - LLM Observability Platform"
requires-python = ">=3.14"
dependencies = [
    # Core Framework
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",

    # Settings & Config (Pydantic v2+)
    "pydantic>=2.10.0",
    "pydantic-settings>=2.7.0",
    "python-dotenv>=1.0.0",

    # Logging
    "loguru>=0.7.0",

    # CORS & Security
    "python-multipart>=0.0.12",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.0",
    "pytest-asyncio>=0.24.0",
    "httpx>=0.28.0",           # For testing FastAPI
    "ruff>=0.8.0",             # Linting
    "mypy>=1.13.0",            # Type checking
]

[tool.setuptools]
package-dir = { "" = "." }

[tool.setuptools.packages.find]
where = ["."]
include = ["app*"]

[tool.ruff]
line-length = 100
target-version = "py314"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP"]
ignore = ["E501"]  # Line too long

[tool.mypy]
python_version = "3.14"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
testpaths = ["tests"]
```

### Step 5: Install Dependencies

```bash
cd backend_python

# Install dependencies with uv
uv sync

# Or with pip if uv not available
pip install -e ".[dev]"
```

---

## File-by-File Implementation

### 1. `app/config/settings.py` - Pydantic Settings

```python
"""
Application settings using Pydantic Settings v2.

Environment variables are loaded from .env file and can be overridden
by actual environment variables.

Pattern validated for high-concurrency asyncio environments.
"""

from typing import Annotated
from pydantic import Field, computed_field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class DatabaseSettings(BaseSettings):
    """Database configuration"""

    sqlite_path: Annotated[
        str,
        Field(
            default="./dbdata/junjo.db",
            description="Path to SQLite database file"
        )
    ]
    duckdb_path: Annotated[
        str,
        Field(
            default="./dbdata/traces.duckdb",
            description="Path to DuckDB database file"
        )
    ]

    model_config = SettingsConfigDict(
        env_prefix="DB_",
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
    )


class IngestionServiceSettings(BaseSettings):
    """Ingestion service gRPC connection settings"""

    host: Annotated[
        str,
        Field(
            default="localhost",
            description="Ingestion service gRPC host"
        )
    ]
    port: Annotated[
        int,
        Field(
            default=50052,
            ge=1,
            le=65535,
            description="Ingestion service internal gRPC port"
        )
    ]

    @computed_field  # type: ignore[prop-decorator]
    @property
    def grpc_url(self) -> str:
        """Computed gRPC URL"""
        return f"{self.host}:{self.port}"

    model_config = SettingsConfigDict(
        env_prefix="INGESTION_",
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
    )


class AppSettings(BaseSettings):
    """Main application settings"""

    # Application
    app_name: Annotated[
        str,
        Field(
            default="Junjo Server",
            description="Application name"
        )
    ]
    debug: Annotated[
        bool,
        Field(
            default=False,
            description="Enable debug mode"
        )
    ]

    # Server
    host: Annotated[
        str,
        Field(
            default="0.0.0.0",
            description="Server host"
        )
    ]
    port: Annotated[
        int,
        Field(
            default=1324,
            ge=1,
            le=65535,
            description="Server port (1324 for dev, 1323 for production)"
        )
    ]

    # CORS
    cors_origins: Annotated[
        list[str],
        Field(
            default=["http://localhost:5151"],
            description="Allowed CORS origins"
        )
    ]

    # Nested settings
    database: Annotated[
        DatabaseSettings,
        Field(
            default_factory=DatabaseSettings,
            description="Database settings"
        )
    ]
    ingestion: Annotated[
        IngestionServiceSettings,
        Field(
            default_factory=IngestionServiceSettings,
            description="Ingestion service settings"
        )
    ]

    @field_validator("cors_origins", mode="before")
    @classmethod
    def parse_cors_origins(cls, v: str | list[str]) -> list[str]:
        """Parse CORS origins from string or list"""
        if isinstance(v, str):
            # Handle JSON array string from env var
            import json
            try:
                return json.loads(v)
            except json.JSONDecodeError:
                # Fallback to comma-separated
                return [origin.strip() for origin in v.split(",")]
        return v

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
    )


# Global settings instance (singleton, loaded once at import)
settings = AppSettings()
```

### 2. `app/config/logger.py` - Loguru Setup

```python
"""
Logging configuration using loguru.

Provides structured logging with JSON output in production
and pretty-printed output in development.

Pattern from wt_api_v2 (validated for production use).
"""

import sys
from loguru import logger

from app.config.settings import settings


def setup_logging() -> None:
    """
    Configure loguru logger.

    - In debug mode: Pretty-printed logs to stdout
    - In production: JSON-formatted logs to stdout for container logging
    """

    # Remove default logger
    logger.remove()

    if settings.debug:
        # Development: Pretty, colorful logs
        logger.add(
            sys.stdout,
            format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
                   "<level>{level: <8}</level> | "
                   "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
                   "<level>{message}</level>",
            level="DEBUG",
            colorize=True,
        )
    else:
        # Production: JSON logs for parsing
        logger.add(
            sys.stdout,
            format="{message}",
            level="INFO",
            serialize=True,  # JSON output
        )

    logger.info(f"Logging configured (debug={settings.debug})")
```

### 3. `app/common/responses.py` - Standard Response Models

```python
"""
Standard API response models.

Provides consistent response formats across all endpoints.
Uses Pydantic v2+ conventions.
"""

from typing import Generic, TypeVar
from pydantic import BaseModel, Field, ConfigDict

T = TypeVar("T")


class HealthResponse(BaseModel):
    """Health check response"""
    status: str = Field(default="ok", description="Health status")
    version: str = Field(default="0.1.0", description="API version")
    app_name: str = Field(description="Application name")

    model_config = ConfigDict(frozen=True)  # Immutable response


class ErrorResponse(BaseModel):
    """Error response"""
    error: str = Field(description="Error message")
    detail: str | None = Field(default=None, description="Detailed error information")


class SuccessResponse(BaseModel, Generic[T]):
    """Generic success response with data"""
    success: bool = Field(default=True)
    data: T = Field(description="Response data")
```

### 4. `app/main.py` - FastAPI Application

```python
"""
Main FastAPI application entry point.

Sets up the FastAPI app with:
- CORS middleware
- Loguru logging
- Health check endpoints
- Feature routers (will be added in later phases)

Pattern from wt_api_v2 (validated for production use).
"""

from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from loguru import logger

from app.config.settings import settings
from app.config.logger import setup_logging
from app.common.responses import HealthResponse


# Set up logging before anything else
setup_logging()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan manager.

    Handles startup and shutdown events.
    """
    # Startup
    logger.info("=" * 60)
    logger.info(f"Starting {settings.app_name}")
    logger.info(f"Python 3.14+ with Pydantic v2")
    logger.info(f"Debug mode: {settings.debug}")
    logger.info(f"Server: {settings.host}:{settings.port}")
    logger.info(f"CORS origins: {settings.cors_origins}")
    logger.info("=" * 60)

    yield

    # Shutdown
    logger.info("Shutting down application")
    # NOTE: In Phase 2, add database cleanup:
    # from app.database.db_config import checkpoint_wal, engine
    # await checkpoint_wal()  # Checkpoint SQLite WAL
    # await engine.dispose()  # Close database connections


# Create FastAPI app
app = FastAPI(
    title=settings.app_name,
    description="LLM Observability Platform - Python Backend",
    version="0.1.0",
    debug=settings.debug,
    lifespan=lifespan,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Health check endpoints
@app.get("/ping", response_model=str, tags=["Health"])
async def ping() -> str:
    """Simple ping endpoint"""
    logger.debug("Ping endpoint called")
    return "pong"


@app.get("/health", response_model=HealthResponse, tags=["Health"])
async def health() -> HealthResponse:
    """Detailed health check endpoint"""
    logger.debug("Health endpoint called")
    return HealthResponse(
        status="ok",
        version="0.1.0",
        app_name=settings.app_name,
    )


# Root endpoint
@app.get("/", tags=["Root"])
async def root() -> dict[str, str]:
    """Root endpoint with API information"""
    return {
        "app": settings.app_name,
        "version": "0.1.0",
        "docs": "/docs",
        "health": "/health",
    }


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "app.main:app",
        host=settings.host,
        port=settings.port,
        reload=settings.debug,
        log_config=None,  # Disable uvicorn logging (we use loguru)
    )
```

### 5. `.env.example` - Environment Variables Template

```bash
# Application Settings
APP_NAME=Junjo Server
DEBUG=true
HOST=0.0.0.0
PORT=1324

# CORS (JSON array format or comma-separated)
CORS_ORIGINS=["http://localhost:5151"]

# Database
DB_SQLITE_PATH=./dbdata/junjo.db
DB_DUCKDB_PATH=./dbdata/traces.duckdb

# Ingestion Service (Go gRPC service)
INGESTION_HOST=localhost
INGESTION_PORT=50052
```

### 6. `.env` - Local Development Variables

```bash
# Copy from .env.example and customize
cp .env.example .env

# Edit .env as needed
```

### 7. `README.md` - Backend Documentation

```markdown
# Junjo Server - Python Backend

Python/FastAPI backend for the Junjo Server LLM observability platform.

## Technology Stack

- **Python 3.14+** (latest stable)
- **FastAPI** (async web framework)
- **Pydantic v2+** (data validation and settings)
- **Loguru** (structured logging)
- **uv** (fast package management)

## Quick Start

### Prerequisites

- Python 3.14+
- [uv](https://github.com/astral-sh/uv) (recommended) or pip

### Installation

```bash
# Install dependencies
uv sync

# Or with pip
pip install -e ".[dev]"
```

### Development

```bash
# Run the development server
uv run python -m app.main

# Or with uvicorn directly
uvicorn app.main:app --reload --port 1324
```

The API will be available at:
- **API**: http://localhost:1324
- **Docs**: http://localhost:1324/docs
- **Health**: http://localhost:1324/health

### Testing

```bash
# Run tests
pytest

# With coverage
pytest --cov=app --cov-report=html
```

## Project Structure

```
backend_python/
├── app/
│   ├── config/          # Settings and configuration
│   ├── features/        # Feature-based modules
│   ├── common/          # Shared utilities
│   └── main.py          # FastAPI app
├── tests/               # Tests
└── pyproject.toml       # Dependencies
```

## Configuration

Configuration is managed via environment variables (see `.env.example`).

Settings are loaded using Pydantic Settings with the following precedence:
1. Environment variables
2. `.env` file
3. Default values in `app/config/settings.py`

## Docker

```bash
# Build
docker build -t junjo-backend:latest .

# Run
docker run -p 1324:1324 --env-file .env junjo-backend:latest
```
```

---

## Docker Setup

### 1. `Dockerfile` - Multi-Stage Alpine Build

Based on wt_api_v2 patterns (validated for production):

```dockerfile
# Stage 1: Base - Install dependencies using uv
FROM python:3.14-alpine AS base

# Install build dependencies
RUN apk add --no-cache \
    git \
    gcc \
    musl-dev \
    libffi-dev

# Install uv
COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/

# Set working directory
WORKDIR /app

# Copy dependency files
COPY pyproject.toml uv.lock* ./

# Install dependencies into virtual environment
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --locked --no-install-project --no-dev

# Stage 2: Production - Final image
FROM python:3.14-alpine AS production

# Install tini for proper signal handling
RUN apk add --no-cache tini

# Set working directory
WORKDIR /app

# Copy virtual environment from base stage
COPY --from=base /app/.venv ./.venv

# Set PATH to use virtual environment
ENV PATH="/app/.venv/bin:$PATH"
ENV PYTHONPATH=/app

# Copy application code
COPY app ./app
COPY .env.example ./.env.example

# Create data directory
RUN mkdir -p ./dbdata

# Expose port
EXPOSE 1324

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:1324/ping')"

# Use tini as entrypoint for proper signal handling
ENTRYPOINT ["/sbin/tini", "--"]

# Run uvicorn
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "1324"]

# Stage 3: Development - Add dev dependencies and hot reload
FROM production AS dev

# Install development dependencies
RUN --mount=type=cache,target=/root/.cache/uv \
    /bin/uv pip install watchfiles

# Override CMD for hot reload
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "1324", "--reload"]
```

### 2. `.dockerignore`

```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
*.egg-info/
dist/
build/
.venv/
venv/
.pytest_cache/
.ruff_cache/
.mypy_cache/

# Environment
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Data
dbdata/
*.db
*.duckdb

# Tests
htmlcov/
.coverage
.pytest_cache/

# Git
.git/
.gitignore
```

### 3. Update `docker-compose.dev.yml`

Add the Python backend alongside the Go backend:

```yaml
services:
  # Existing Go backend (keep running during migration)
  junjo-server-backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "1323:1323"
    environment:
      - SQLITE_DB_PATH=/dbdata/junjo.db
      - DUCKDB_PATH=/dbdata/traces.duckdb
      - INGESTION_SERVICE_INTERNAL_HOST=junjo-server-ingestion
      - INGESTION_SERVICE_INTERNAL_PORT=50052
    volumes:
      - ./dbdata:/dbdata
    depends_on:
      - junjo-server-ingestion
    networks:
      - junjo-network

  # NEW Python backend (adjacent for testing)
  junjo-server-backend-python:
    build:
      context: ./backend_python
      dockerfile: Dockerfile
      target: dev  # Use dev stage for hot reload
    ports:
      - "1324:1324"  # Different port for parallel testing
    environment:
      - DEBUG=true
      - APP_NAME=Junjo Server (Python)
      - DB_SQLITE_PATH=/dbdata/junjo.db
      - DB_DUCKDB_PATH=/dbdata/traces.duckdb
      - INGESTION_HOST=junjo-server-ingestion
      - INGESTION_PORT=50052
      - CORS_ORIGINS=["http://localhost:5151"]
    volumes:
      - ./dbdata:/dbdata
      - ./backend_python/app:/app/app  # Hot reload
    depends_on:
      - junjo-server-ingestion
    networks:
      - junjo-network

  # Ingestion service (unchanged)
  junjo-server-ingestion:
    build:
      context: ./ingestion-service
      dockerfile: Dockerfile
    ports:
      - "50051:50051"  # Public gRPC
      - "50052:50052"  # Internal gRPC
    environment:
      - BADGERDB_PATH=/wal-data
    volumes:
      - ./wal-data:/wal-data
    networks:
      - junjo-network

  # Frontend (unchanged - can test against either backend)
  junjo-server-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: development
    ports:
      - "5151:80"
    environment:
      # Point to Python backend for testing
      - VITE_API_URL=http://localhost:1324
    networks:
      - junjo-network

networks:
  junjo-network:
    driver: bridge
```

---

## Testing

### Manual Testing

#### 1. Start the Development Server

```bash
cd backend_python

# Option A: Run directly with Python
python -m app.main

# Option B: Run with uvicorn
uvicorn app.main:app --reload --port 1324

# Option C: Run with Docker
cd ..
docker compose -f docker-compose.dev.yml up junjo-server-backend-python
```

#### 2. Test Health Endpoints

```bash
# Ping
curl http://localhost:1324/ping
# Expected: "pong"

# Health
curl http://localhost:1324/health
# Expected: {"status":"ok","version":"0.1.0","app_name":"Junjo Server"}

# Root
curl http://localhost:1324/
# Expected: {"app":"Junjo Server","version":"0.1.0","docs":"/docs","health":"/health"}
```

#### 3. Test OpenAPI Docs

Open in browser:
- http://localhost:1324/docs (Swagger UI)
- http://localhost:1324/redoc (ReDoc)

#### 4. Test CORS

```bash
# From frontend (localhost:5151), make a request
fetch('http://localhost:1324/ping')
  .then(r => r.text())
  .then(console.log)
# Should succeed (CORS headers present)
```

#### 5. Test Hot Reload

```bash
# Start dev server
uvicorn app.main:app --reload --port 1324

# Edit app/main.py, change "pong" to "pong!"
# Save file
# Server should auto-reload

# Test
curl http://localhost:1324/ping
# Expected: "pong!"
```

### Automated Testing

Create `tests/test_main.py`:

```python
"""
Tests for main application endpoints.
"""

import pytest
from httpx import AsyncClient, ASGITransport
from app.main import app


@pytest.mark.asyncio
async def test_ping():
    """Test ping endpoint"""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        response = await client.get("/ping")
        assert response.status_code == 200
        assert response.text == '"pong"'


@pytest.mark.asyncio
async def test_health():
    """Test health endpoint"""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        response = await client.get("/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "ok"
        assert data["version"] == "0.1.0"
        assert "app_name" in data


@pytest.mark.asyncio
async def test_root():
    """Test root endpoint"""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        response = await client.get("/")
        assert response.status_code == 200
        data = response.json()
        assert "app" in data
        assert "version" in data
        assert "docs" in data
```

Run tests:

```bash
cd backend_python

# Run tests
pytest

# With coverage
pytest --cov=app --cov-report=html
```

---

## Success Criteria

Phase 1 is complete when:

- ✅ `backend_python/` directory structure created
- ✅ Python 3.14 specified in `.python-version`
- ✅ `uv` or `pip` dependencies installed successfully
- ✅ FastAPI app starts on port 1324
- ✅ `GET /ping` returns `"pong"`
- ✅ `GET /health` returns JSON with status, version, app_name
- ✅ `GET /` returns API information
- ✅ OpenAPI docs accessible at `/docs` and `/redoc`
- ✅ CORS allows requests from `http://localhost:5151`
- ✅ Loguru logging outputs pretty logs in debug mode
- ✅ Pydantic Settings loads from `.env` correctly
- ✅ Hot reload works (file changes trigger auto-restart)
- ✅ Docker build succeeds (both production and dev targets)
- ✅ Docker container starts and responds to health checks
- ✅ `docker compose up junjo-server-backend-python` works
- ✅ Automated tests pass (`pytest`)

---

## Troubleshooting

### Issue: `uv` command not found

**Solution:**
```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Add to PATH
export PATH="$HOME/.cargo/bin:$PATH"

# Or use pip as fallback
pip install -e ".[dev]"
```

### Issue: Python 3.14 not available

**Solution:**
```bash
# Install Python 3.14 with pyenv
pyenv install 3.14.0
pyenv local 3.14.0

# Or use system Python if 3.14+
python --version  # Should be 3.14+
```

### Issue: `ModuleNotFoundError: No module named 'app'`

**Solution:**
```bash
# Ensure PYTHONPATH is set
export PYTHONPATH=/path/to/backend_python:$PYTHONPATH

# Or run from backend_python directory
cd backend_python
python -m app.main
```

### Issue: Port 1324 already in use

**Solution:**
```bash
# Find process using port
lsof -i :1324

# Kill process
kill -9 <PID>

# Or use different port
uvicorn app.main:app --port 1325
```

### Issue: CORS errors in browser

**Solution:**
1. Check `.env` has correct `CORS_ORIGINS`:
   ```bash
   CORS_ORIGINS=["http://localhost:5151"]
   ```
2. Restart server after changing `.env`
3. Verify CORS headers in browser DevTools Network tab

### Issue: Docker build fails with uv errors

**Solution:**
```bash
# Clear Docker cache
docker builder prune -af

# Rebuild without cache
docker build --no-cache -t junjo-backend:latest .

# Check if uv.lock exists
ls -la backend_python/uv.lock

# Regenerate lock file
cd backend_python
uv lock
```

### Issue: Settings not loading from .env

**Solution:**
1. Verify `.env` file exists in `backend_python/`
2. Check environment variable names match `model_config.env_prefix`
3. Print settings to debug:
   ```python
   from app.config.settings import settings
   print(settings.model_dump())
   ```

---

## Next Steps

Once Phase 1 is complete:

1. ✅ Verify all success criteria met
2. ✅ Commit changes to git
3. ✅ Update main `PYTHON_BACKEND_MIGRATION_0_Master.md` with Phase 1 completion
4. ➡️ **Proceed to Phase 2**: SQLAlchemy + Alembic Setup

---

## References

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [Pydantic Settings](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)
- [Loguru Documentation](https://loguru.readthedocs.io/)
- [uv Documentation](https://github.com/astral-sh/uv)
- [wt_api_v2 Reference](file:///Users/matt/repos/wt_api_v2)
- [Python 3.14 Release Notes](https://docs.python.org/3.14/whatsnew/3.14.html)
